# 확률





## 빈도론적 확률

- 일반적으로 잘 알려진 확률 (고전 확률)
- 어떤 사건을 반복해서 관찰했을 때, 발생하는 상대 빈도수
- 수집된 자료들의 변수들도 확률적으로 주어지는 값으로 해석 (확률변수)



## Laplace 확률

- 표본공간의 각 원소들이 일어날 가능성이 같다고 가정
- 일반적으로 표본공간의 갯수가 유한하고
- 원소 모두를 알고 있을 때 사용할 수 있음



## 확률의 공리

- 확률의 단순한 정의
- 확률은 항상 0보다 크거나 같고, 1보다 작거나 같다.
- 전체사건 S에 대해 각각의 사건들이 상호배반적 이라면,
- 각 사건들이 발생하는 확률은 각 확률을 더한것과 같다.



## 확률분포

- ```python
  dice = [1, 2, 3, 4, 5, 6]
  prob = [1/21, 2/21, 3/21, 4/21, 5/21, 6/21]
  num_trial = 100
  sample = np.random.choice( dice, num_trial, p=prob)
  sample
  array([6, 3, 6, 1, 2, 5, 2, 6, 6, 5, 5, 3, 4, 6, 6, 5, 6, 3, 3, 6, 6, 3,
         2, 2, 4, 6, 4, 6, 3, 3, 6, 4, 3, 5, 2, 3, 6, 4, 3, 6, 6, 4, 6, 2,
         5, 5, 4, 3, 4, 6, 6, 6, 3, 6, 5, 3, 4, 2, 4, 6, 6, 4, 3, 3, 5, 2,
         6, 3, 5, 4, 4, 4, 6, 4, 5, 6, 6, 6, 4, 6, 4, 4, 6, 3, 6, 5, 5, 3,
         6, 6, 5, 3, 5, 5, 5, 5, 2, 4, 6, 3])
  ```
  
- ```python
  freq, _ = np.histogram(sample, bins=6, range=(1,7))
  pd.DataFrame( {'빈도수':freq, '상대 빈도수':freq/num_trial}, index=pd.Index(np.arange(1,7), name='dice'))
  	빈도수	상대 빈도수
  dice		
  1		1	0.01
  2		9	0.09
  3		20	0.20
  4		19	0.19
  5		18	0.18
  6		33	0.33
  ```

- 



## 확률변수와 확률분포





### 확률변수

- 확률적인 과정에 따라 값이 결정되는 변수,함수
- 수집된 자료의 변수들도 확률적 과정에 따라 주어진다



### 확률분포

- 확률변수가 특정한 값을 가지게 될 확률을 나타내는 함수
- 일반적으로 잘 알려진 확률분포를 가정



#### 이산확률변수

- 확률변수가 이산적인 값을 가질 때
- 셀 수 있는 값, 범주형 자료
- 베르누이 분포, 이항 분포 등
- 이때의 확률분포를 확률변수 x의 확률질량함수(pmf) 라고 한다



#### 이산확률분포

- 베르누이 분포
  - 가능한 사건의 경우가 두 가지로 구분되는 시행 : '베르누이 시행'
  - 성공, 실패로 구분되는 경우
  - 0(실패), 1(성공)으로 구분해서 간단하게 나타냄



- 주사위를 던졌을 때 특정 눈금이 나오는 경우를 성공으로 가정
  - 성공확률이 1/6인 베르누이 분포를 따름
  - 표본의 자료가 베르누이 분포를 따른다면, 모집단의 성공확률은?
  - 



- 표본추출

  - 파이썬에서는 각 객체들마다 난수를 생성하는 함수를 지원

  - ```python
    count = 100
    x = rv.rvs( count )
    x
    
    array([0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0,
           0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0,
           0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1,
           0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0])
    
    np.bincount(x) / count
    array([0.77, 0.23])
    ```



- 이항분포 (binom distribution)

  - 베르누이 시행을 여러번 했을 경우의 분포

  - ex) 주사위 10번 던져서 1이 나오는 경우를 성공으로 가정

  - 시행횟수가 1이면 베르누이 분포와 같음

  - ```python
    binom(1, 1/6).pmf([0,1])
    array([0.83333333, 0.16666667])
    
    rv = binom(10, 1/6)
    x = np.arange(11)
    rv.pmf(x)
    array([1.61505583e-01, 3.23011166e-01, 2.90710049e-01, 1.55045360e-01,
           5.42658759e-02, 1.30238102e-02, 2.17063503e-03, 2.48072575e-04,
           1.86054431e-05, 8.26908584e-07, 1.65381717e-08])
    ```

  - 표본추출

  - ```python
    x = rv.rvs(10000)
    sns.countplot(x)
    plt.show()
    ```



- 누적분포함수

  - 주어진 확률변수가 특정값보다 크거나 작아질 확률

  - 누적분포함수는 항상 0과 1사이의 값을 가짐

  - ex) 주사위를 10번 던질때 1이 3번이하로 나올 확률

  - 파이썬에서는 cdf함수를 이용하여 누적분포함수를 계산

  - ```python
    x = np.arange(11)
    rv.cdf(x)
    array([0.16150558, 0.48451675, 0.7752268 , 0.93027216, 0.98453803,
           0.99756184, 0.99973248, 0.99998055, 0.99999916, 0.99999998,
           1.        ])
    
    plt.plot(x, rv.cdf(x))
    plt.show()
    
    prob = rv.cdf(x)
    prob[3]  # 1이 3번이하 나올 확률
    ```



- 포아송 분포

  - 시간, 면적 등을 구간으로 나눠서 표현
  - 각 구간별 사건은 독립적이고, 사건의 발생확률은 동일 (베르누이와 동일)
  - 각 구간의 사건 발생확률은 구간의 크기에 비례
  - 정해진 시간 안에 어떤 사건이 일어날 횟수에 대한 값을 람다라고 하면
  - 사건이 k회 일어날 확률

  

  ex) 하루평균 2건의 사고가 발생하는 지역에서, 하루 사고발생 건수

  - ```python
    rv = poisson(2)  # 람다값
    x = np.arange(11)  
    plt.bar(x, rv.pmf(x))
    plt.show()
    ```

  - 표본추출

  - ```python
    x = rv.rvs(10000)  
    sns.countplot(x)
    plt.show()
    
    x.mean()  # 표본의 평균?  =>  람다에 근사
    ```

  

  

#### 연속확률변수

- 확률변수가 연속적인 값을 가지는 경우를 연속확률변수 라고 한다
- 이때의 확률분포를 확률변수의 확률밀도함수 라고 한다
- 가장 대표적인것이 정규분포



- 정규분포 (Normal Distribution)

  - 가우스분포 라고도 함

  - 선형회귀 모형에서는 자료의 분포, 오차항의 분포를 정규분포로 가정

  - 평균이 0이고, 표준편차가 1인 정규분포를 표준정규분포 라고 한다

  - ```python
    from scipy.stats import norm
    rv = norm( loc=0, scale=1 ) # 표준정규분포
    
    x = np.linspace(-5, 5, 1000)
    plt.plot(x, rv.pdf(x))
    plt.show()
    ```



- 정규분포의 누적분포함수

  - 수학적으로는 구할 수 없으나 파이썬은 근사한 결과를 돌려줌

  - 일반화선형모형의 logit함수

  - 딥러닝의 활성화함수 등

  - ```python
    x = np.linspace(-3, 3, 1000)
    plt.plot(x, rv.cdf(x))
    plt.show()
                    
    ```



# 중심극한의 정리

- 통계적 모형을 세울 때, 정규분포를 사용할 수 있는 중요한 이론

- 모집단의 분포가 무엇이든 상관없이 표본의 크기가 충분하다면

- 표본들의 평균은 결국 정규분포로 수렴하게 된다

- 자료의 분포가 정규분포임을 증명해주는 것은 아니다

- ```python
  # 균등분포를 가정
  from scipy.stats import uniform # 균등분포
  n = 3
  m = 1000
  mean = []
  rv = uniform(n)
  for _ in range(m) : 
      x = rv.rvs(n)
      mean.append(x.mean())
      
  sns.displot(mean)
  # 보통 n이 20정도면 충분한 값으로 본다
  # m(시행)이 늘어나면 정규분포에 가까워진다
  ```



# 몬테카를로 시뮬레이션

- 난수를 이용해서 시행하는 모의실험
- 아주 많은 연산을 필요로 하는 경우에 효과적인 알고리즘이 필요
- 난수를 이용해 푸는 방법을 제안
- 실제 분포를 모르는경우에 시뮬레이션을 통해 표본을 추출함



## 도박사 예시

- 도박사가 얼마만에 파산을 할지 시뮬레이션 해보자
- 이 경우에는 확률분포를 가정하기 어렵다
- 따라서 시뮬레이션을 통해 표본을 추출, 이를 통해 모집단의 모수를 추정함
- 모수란? 평균, 분산 등



## 승률

- 게임마다 승률이 다르게 설정

- 일반적으로 49%를 넘어가지 않음

- 성공확률 49%인 베르누이 분포를 가정해보자

- ```python
  # 초기자금 10,000 원
  # 49%의 확률로 100원을 따거나 51%의 확률로 100원을 잃는 베르누이 분포
  # 도박사는 얼마만에 파산할까? (파산하지 않는 경우는 고려x)
  
  n = 10000
  p = 0.49
  r = []
  x = [-100, 100]
  
  while True:
      i = bernoulli(p).rvs(1)[0]
      n += x[i]
      r.append(n)
      if n<0 : break
          
  plt.plot(r)
  plt.show()
  ```



- 이때, 도박사가 파산할 때 까지의 게임횟수를 m이라고 하면

- m이 확률변수가 된다

- 평균적으로 몇회만에 파산하는지를 확인해보자

- ```python
  # 1000회의 시뮬레이션을 진행
  p = 0.49
  m = []
  x = [-100, 100]
  
  for _ in range(1000):
    n = 10000
    cnt = 0
    while True:
      cnt += 1
      i = bernoulli(p).rvs(1)[0]
      n += x[i]
      if n < 0: break
    m.append(cnt)
  ```

- 































